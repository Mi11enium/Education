# Дисковая операционная система
### DOS обеспечивает операционную среду, в которой выполняются другие программы
ФУНКЦИИ DOS

Программа использует функции DOS посредством программного прерывания. Благодаря этому, программа может вызывать соответствующую служебную программу, не зная ее адреса. Нужное прерывание задается программистом. А во время инициализации DOS векторы прерывания для функций системы определяются таким образом, чтобы они указывали на соответствующие подпрограммы.

Прерывание Действие
21H Вызов функции
Значение
в AH Функция
2 Вывод на экран
9 вывод строки

Прерывание 21H является прерыванием, через которое происходи обращение к основным функциям DOS. Это прерывание обеспечивает доступ к системе ввода-вывода, управляемой DOS.

Выбор функции в программе осуществляется с помощью записи в регистр AH нужного значения перед выполнением прерывания 21H.

### Язык Ассемблера

> [!attention] Ассемблер
> **Язык ассемблера** — это **язык символического кодирования двоичных кодов машинных команд и имен данных**. Специальная программа, называемая программой-ассемблером, переводит символические обозначения в двоичные коды операций и адреса переменных и, кроме того, распределяет память для программы, подпрограмм и данных и выполняет другую работу по отладке и выполнению программы.


***
### Программы-ассемблеры для микропроцессоров семейства 80х86 фирмы Intel

Процессоры фирмы Intel (8086, 8088, 80286, 80386, 80486, Pentium, Pentium Pro) объединяют в семейство 80х86, поскольку в них соблюдается преемственность: программа, написанная для младшей модели может без каких-либо изменений выполнена на любой более старшей модели. Обеспечивается это тем, что в основе всех этих процессоров лежит система команд 8086, в старшие же модели лишь добавляются новые команды (необходимые, главным образом, для реализации многозадачного режима). Процессоры 8086, 8088 и 80286 являются 16-разрядными, 80386 и 80486 - 32-разрядными, а, начиная с Pentium - 64-разрядными. Начиная с процессора 80286 эти процессоры могут работать в двух режимах - реальном, фактически представляющем собой очень быстрый вариант процессора 8086 и в защищенном, позволяющем реализовать многозадачный режим работы.

Для языка ассемблера процессоров 80х86 существует несколько реализаций, наиболее распространенными из которых является макроассемблер фирмы Microsoft (MASM) и Turbo Assembler фирмы Borland (TASM).
***
### Алфавит и идентификаторы языка ассемблера
> [!attention] Алфавит
> **Алфавит** - (совокупность допустимых символов) языка ассемблер включает: прописные и строчные буквы латинского алфавита, цифры и набор специальных символов.

Не допустимый символ программа-ассемблер переводит в пробел.

Для обозначения различных объектов программы: переменных, меток, символических имен команд и т.д. в ассемблере используются **идентификаторы**.

Идентификатор - это последовательность из латинских букв (прописных или строчных), цифр и следующих знаков:
? . @ _ $
идентификатор не должен начинаться с цифры.
***
### Команды
> [!attention] Команды
> **Предложения-команды** - это символьная форма записи машинных команд. Формат записи команд следующий: метка: мнемокод операнды; комментарий.

Метка (идентификатор команды) нужна для ссылок на команду из других мест программы, например для перехода на эту команду. Поскольку не на все команды необходимы ссылки, метка в команде может отсутствовать (в этом случае первым идентификатором в команде является мнемокод). Если метка есть, после нее обязательно должно следовать двоеточие.

Мнемокод (мнемонический код) является обязательной частью команды. Это служебное слово, которое в языке ассемблер нельзя использовать для других целей (например, в качестве имени переменной). Мнемокод указывает в символьной форме операцию, которую должна выполнить команда. Мнемокоды операций будут рассмотрены при описании отдельных команд ассемблера.

Если операндов в команде несколько, они отделяются друг от друга запятыми.

В конце команды можно поместить комментарий, поставив символ “;” и записав за ним любой текст. Этот комментарий обычно используется для пояснения действий данной команды.

Пример записи команд:

lab: add si,2; изменение индекса.
***
### Директивы

Помимо команд в программе надо указать ассемблеру и другие вещи (например, опеределить переменные, используемые в программе). Такие действия выполняются с помощью директив ассемблера, имеющих следующий формат:

имя название_директивы операнды; комментарий

Как видно, формат директив в целом совпадает с форматом команд.

Пример директивы:

x db 10,-5, 0ffh; массив x.
***
### Константы

В языке ассемблера в командах и директивах оператора могут использоваться целые, вещественные и строковые константы.

**Целые константы** могут быть записаны в десятичной, двоичной, восьмиричной или шестнадцатиричной системе счисления.

Признаком системы счисления является односимвольный идентификатор в конце числа:

- d - для десятичных констант;
- b - для двоичных констант;
- q или o - для восьмеричных констант;
- h - для шестнадцатиричных констант.

Если идентификатор системы счисления отсутствует, считается, что константа записана в десятичной системе счисления.

**Вещественные константы**, записываются в общем виде как выpажения вида:
[+/-]целое.дpобь[E[+/-]степень]
(выражения в квадратных скобках могут быть опущены). Примеры записи вещественных констант:

98.6 -5.391E4 7.391E-7

**Строковые константы** могут содержать любые символы кода ASCII. Строковые константы заключаются в одиночные или двойные кавычки.

Примеры строковых констант:

‘a’ ‘abc’ ‘don’’t’ “f” “”” плавающая”” точка”.
***
### Директивы определения данных

Директивы определения данных предназначены для **описания переменных**, с которыми работает программа.

Имя директивы задает имя описываемой переменной (или группы переменных), а название директивы - размер памяти выделяемую перед переменную или элемент группы переменных с заданным именем.

В языке ассемблера можно задать следующие названия директив для выделения памяти под переменные или группы переменных:
- db (define byte) - выделить один байт;
- dw (define word) - выделить слово (2 байта);
- dd (define double word) - выделить двойное слово (4 байта);
- dq (define quad word) - выделить четвертное слова (8 байт);
- dt (define ten bytes) - выделить 10 байт.

Директива определения данных должна содержать один или несколько операндов. В качестве операнда может выступать:

- символ “?”;
- константа;

Задание символа “?” в качестве операнда означает, что значение данной переменной не определено и директивой определения данных ей просто выделяется память указанного размера.

Если операндом памяти является числовая константа, то переменной выделяется память и ей присваивается значение, т.е. переменная инициализируется.

**_Примеры записи директив определения данных с одним операндом:_**
x1 db?; для переменной x1 выделен один байт (ее значение не определено)
u12 dd (var_1-10)/2; для переменной u12 выделено 4 байта и ее начальное; значение вычисляется

q dw?; под переменную q выделено слово (2 байта)

v db type q; переменной v будет присвоено значение длины q, т.е. 2


**_Пример записи директивы определения данных с несколькими операндами:_**
m db 2,-2,?,? ; задан массив m из четырех элементов

Приведенная директива является более короткой формой записи следующих директив:
m db 2
db -2
db ?
db ?

Строковые переменные, фактически являющиеся массивами символов, могут быть описаны в директиве db с помощью одного или нескольких операндов. Например, представления строковой переменной str1 со значением ‘abc’ в виде:

str1 db ‘abc’ или str1 db ‘a’,’b’,c’ или str1 db ‘a’,’bc’ или
str1 db ‘a’
db ‘b’
db ‘c’

являются эквивалентными.

В случае, когда среди операндов директивы определения данных среди значений операндов имеются одинаковые повторяющие значения, для сокращения записи можно использовать оператор dup, который записывается следующим образом:

1.  коэф_повт dup (значение1, значение2,...)
2.  где коэф_повт - коэффициент повторения (константа или выражение) заданных значений.

**_Примеры записи директив определения данных с использованием dup:_**

1.  a dw 10 dup(0) ;задан массив a из 10 элементов, которым присвоено значение 0
2.  out_str db 12 dup(“ “), “Заголовок текста” ; строка содержит 12 пробелов и текст
***
### Директивы эквивалентности и присваивания
**Директива присваивания** “=” определяет константу с именем, указанным в левой части и со значением, указанным в правой части.. константа может быть переопределена в ходе выполнения программы.

**_Пример записи директивы присваивания:_**
k = 10; k присвоено значение 10.
***
### Структура программы на языке ассемблер
Пpогpаммиpование на языке ассемблер пpедусматpивает pазбиение пpогpаммы на логические сегменты, pазмеp котоpых не пpевышает 64 Kбайт.

Cегмент в программе имеет следующий вид:

1.  имя segment параметры
2.  предложение_1
3.  предложение_1
4.  ..........................
5.  предложение_n
6.  имя ends
7.  где имя - имя сегмента, параметры - параметры сегмента (могут быть опущены).

Программа на языке ассемблера (программный модуль) завершается директивой:

end метка

где метка - метка первой исполняемой строки программного модуля.

Определение сегментов с использованием директив segment осуществляет только размещение и инициализацию переменных в конкретной, логически определенной области. Для организации доступа в программе к таким областям-сегментам, необходимо иметь возможность адресоваться через регистры, указав какой регистр является опорным (базовым) для каждого сегмента.

Привязка конкретного сегментного регистра к определенному сегменту для осуществляется директивой assume, имеющей один из следующих форматов:

assume имя_сегм_регистра:имя_сегмента

Эта форма записи связывает имя_сегмента определенным сегментным регистром имя_сегм_регистра.

Для директивы сегмента стековых данных обычно указывается операнд stack, который вызвает автоматическую загрузку сегментного регистра SS с адресом указанного сегмента.

Сегментный регистр данных загружается с помощью следующих двух команд:

mov ax,имя_сегмента
mov ds,ax

Регистр CS, если он используется как регистр сегмента команд, загружать не надо, поскольку к началу выполнения программы он уже указывает на начало сегмента программ.

Следует заметить, что даже если сама программа не использует стек, описывать стек все равно надо, так как стек программы использует операционная система (например, для обработки прерываний при вводе/выводе). Минимальный размер стековой памяти в этом случае - 128 байт.

С учетом сказанного типичной при написании программ на языке ассемблера является следующая структура:

-   stack segment stack; сегмент стека
-   db 128 dup(?)
-   stack ends
-   data segment; сегмент данных

_директивы описания данных_

-   data ends
-   code segment; сегмент команд
-   assume cs:code,ds:data,ss:stack
-   start:
-   mov ax,data ; загрузка
-   mov ds,ax ; регистра ds

_команды и директивы программы_

-   code ends
-   end start.
***
### Процедуры.
> [!attention] Процедуры
> **Процедура**, часто называемая также _подпрограммой_, — это основная функциональная единица декомпозиции (разделения на несколько частей) некоторой задачи.

Процедура представляет собой группу команд для решения конкретной подзадачи и обладает средствами получения управления из точки вызова задачи более высокого уровня и возврата управления в эту точку.

В простейшем случае программа может состоять из одной процедуры. Другими словами, процедуру можно определить, как правильным образом оформленную совокупность команд, которая, будучи однократно описана, при необходимости может быть вызвана в любом месте программы.

Для описания последовательности команд в виде процедуры в языке ассемблера используются две директивы: **PROC** и **ENDP**.

ИМЯ **PROC NEAR (FAR)**

ИМЯ **ENDP**

_Параметр_ указывает тип процедуры и может иметь значение NEAR (близкий) или FAR (дальний). Если параметр отсутствует, считается, что он равен NEAR. К близкой процедуре можно обращаться только из того сегмента команд, в котором она описана, а к дальней процедуре можно обращаться из любых сегментов команд (в том числе и из того, где она описана).
***
### Процедуры в программе на ассемблере обычно размещают в тех местах, где на нее не попадает управления во время выполнения программы, а именно:
- в конце сегмента команд за командой FINISH.
- в самом начале сегмента команд - перед той командой, с которой должно начинаться выполнение программы.
- на участках программы, выполнение которых обходится при работе программы с помощью команды безусловного перехода.
- в отдельном сегменте команд (обычно в больших программах).

Если имеется несколько процедур, их обычно размещают рядом.

Процедуру в языке ассемблера можно вызвать с помощью команды безусловного или условного перехода. Вызывающая программа должна также сообщить процедуре адрес возврата - адрес той команды основной программы, на которую процедура должна сделать переход по окончании своей работы (обычно это адрес команды, следующей за командой обращения к процедуре).

Сообщить адрес возврата можно либо через регистр, либо через память, либо через стек. Стандартным является последний способ, для реализации которого имеются специальные команды:

1.  CALL _операнд_
2.  RET

Команда CALL записывает адрес следующей за ней команды в стек и затем осуществляет переход на первую команду указанной процедуры (в качестве операнда может быть задана, так же как и для команды безусловного перехода, либо метка процедуры, либо имя регистра или ячейки памяти). Команда RET считывает из вершины стека адрес и выполняет переход по нему.

Вызов процедур и возврат из процедур могут быть дальними или близкими. Если процедура описана до ее вызова, транслятор сам определяет тип вызова, однако, если описание процедуры находится после ее вызова, транслятор предполагает, что процедура близкая, поэтому при обращении к дальней процедуре, надо в команде CALL с помощью оператора PTR явно указать, что процедура дальняя, например:

CALL FAR PTR L1
***
### Условные переходы Микропроцессор имеет 18 команд условного перехода. Эти команды позволяют проверить:
- отношение между операндами со знаком (“больше — меньше”);

отношение между операндами без знака (“выше — ниже”)2;

состояния арифметических флагов zf, sf, cf, of, pf (но не af).